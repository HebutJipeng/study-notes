Q1： js是解释执行，每一个代码块的执行过程：语法分析，预编译阶段，解释执行，其中预编译阶段会对变量和函数做一些处理：
函数及变量的声明都将被提升到函数的最顶部；
对于变量赋值会先开辟一块内存空间并指向变量名，且赋值为undefined；
对于函数声明，则会直接将函数体处理后放入开辟的内存空间，即用函数声明方式，在预编译阶段便已完成了函数的创建工作。


**Q2：**为什么export和import只能在模块最外层作用域，为什么不能在条件语句内？
因为对import和export是在静态分析阶段做的分析处理，而条件语句要等到执行时才会解析到。

**Q3：**前端模块化的探索历程：
函数：污染全局变量，命名冲突；
命名空间(简单对象封装)：命名空间过长；可以直接修改内部数据，不安全；
立即执行函数(闭包)：私有数据，提供暴露接口；支持传入依赖；（模块化雏形）

需要解决的问题：文件依赖管理，脚本引入顺序，按需加载等问题；


服务端：commonJs ；浏览器端： AMD（依赖前置） | CMD（依赖后置）


ESModule


es module
 - 尽量静态化，在编译时就确定模块的依赖关系，以及输入输出的变量；

```html
<script type="module" src="module-entry.js"></script>
<script nomodule type="text/javascript" src="nomodule.js"></script>
```

支持 ES6 模块的浏览器会根据 <script> 标签上的 type="module" 来加载 ES6 模块；而忽略带有 nomodule 的 <script> 标签。不支持的浏览器则会忽略 type="module" 的 <script> 标签，忽略 <script> 标签上的 nomodule 的属性。

使用浏览器原生对 ES6 模块的支持特性，可以享受模块级别的缓存这一优势。

在模块中引入其他模块时，需要添加 .js 后缀。模块中可以使用 export 和 import 关键字。
